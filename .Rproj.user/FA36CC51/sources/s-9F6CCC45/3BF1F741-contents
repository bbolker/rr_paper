library(glmmTMB)
library(foreign)
library(tidyverse)
library(TMB)
source("functions.R")

load("Data/pirls_cat.RData")

pirls <- pirls %>%
  droplevels()
pirls <- within(pirls, Eco_disad <- relevel(Eco_disad, ref = "0 to 10%"))
pirls <- within(pirls, Size_lib <- relevel(Size_lib, ref = "500 Book Titles or Fewer"))
pirls_df <- pirls %>%
  select(Overall1, Student_ID, School, SchoolsInCountry, Country, Eco_disad, Size_lib)
pirls_sub <- pirls_df %>%
  filter(as.numeric(Country) < 10 & as.numeric(School) < 15)
pirls_sub$Overall <- pirls_sub$Overall1
pirls_sub$School <- pirls_sub$SchoolsInCountry
pirls_sub <- na.omit(pirls_sub)
# pirls_NAomit <- na.omit(pirls_df)
###----- Interaction: School location and eco disadvantage
# pirls <- pirls_NAomit
# pirls <- pirls_df
# pirls$Overall <- pirls$Overall1
# pirls$School <- pirls$SchoolsInCountry

#### ---------------------
#### Simple case: 1 re
#### ---------------------
rank = 2
fit.rr <- glmmTMB(Overall ~  Eco_disad +Size_lib +
                    rr(Eco_disad + Size_lib| Country, 2), #+
                    # diag(Eco_disad + Size_lib| Country) ,
                  data = pirls_sub,
                  family = gaussian(),
                  control = glmmTMBControl(optCtrl=list(iter.max=1e5,eval.max=1e3),
                                           start_method = list(method = "res")))


object <- fit.rr

listname <- "cond"
cnms <- object$modelInfo$reTrms[[listname]]$cnms   ## list of (named) terms and X columns
reStruc <- object$modelInfo$reStruc[[paste0(listname, "ReStruc")]] ## random-effects structure
flist <- object$modelInfo$reTrms[[listname]]$flist ## list of grouping variables
levs <- lapply(flist, levels)

fl <- fit.rr$obj$env$report(fit.rr$fit$parfull)$fact_load[[1]]
rownames(fl) <- cnms$Country
u <- as.matrix(ranef(fit.rr)$cond$Country[,1:2])
b.rr <- fl%*% t(u)
b.rr.long <- as.data.frame(b.rr) %>%
  rownames_to_column("Coefficient") %>%
  pivot_longer(cols = -Coefficient, names_to = c("Country"), values_to = "lu" )

pl <- object$obj$env$parList(object$fit$par, object$fit$parfull)
b0 <- which(pl$b==0)
s1 <- TMB::sdreport(object$obj,  getJointPrecision = TRUE)
h.inv <- solve(s1$jointPrecision)
h.inv.b <- h.inv[rownames(h.inv)=="b", colnames(h.inv)=="b"]
h.inv.u <- h.inv.b[-b0, -b0]

I <- diag(rep(1, ncol(b.rr)))
I.fl <- kronecker(I, (fl))
rownames(I.fl) <- rep(cnms$Country, ncol(b.rr))
rownames(h.inv.u) <- colnames(h.inv.u) <- rep(levs$Country, 2)
H.l.u <- I.fl %*% h.inv.u %*% t(I.fl)
diag.H.lu <- diag(l.u)
diag.H.lu.df <- cbind(rownames(l.u), as.data.frame(diag.H.lu))
nam.grp <- rep(levs$Country, each =nrow(fl))
var.re <- cbind(diag.H.lu.df, nam.grp)
names(var.re) <- c("Coefficient", "var.lu", "Country")

ranef.rr <- left_join(b.rr.long, var.re, by = intersect(names(b.rr.long), names(var.re)))
ranef.rr$sd.lu <- sqrt(ranef.rr$var.lu)


#### ---------------------
#### Case 2: 1 rr and 1 diag
#### ---------------------
rank = 2

fit.rr2 <- glmmTMB(Overall ~  Eco_disad +Size_lib +
                    rr(Eco_disad + Size_lib| Country, 2) +
                  diag(Eco_disad + Size_lib| Country) ,
                  data = pirls_sub,
                  family = gaussian(),
                  control = glmmTMBControl(optCtrl=list(iter.max=1e5,eval.max=1e3),
                                           start_method = list(method = "res")))


object <- fit.rr2

listname <- "cond"
cnms <- object$modelInfo$reTrms[[listname]]$cnms   ## list of (named) terms and X columns
reStruc <- object$modelInfo$reStruc[[paste0(listname, "ReStruc")]] ## random-effects structure
flist <- object$modelInfo$reTrms[[listname]]$flist ## list of grouping variables
levs <- lapply(flist, levels)
pl <- object$obj$env$parList(object$fit$par, object$fit$parfull)
nc <- vapply(reStruc, function(x) x$blockSize, numeric(1)) ## number of RE params per block
nb <- vapply(reStruc, function(x) x$blockReps, numeric(1)) ## number of blocks per RE (may != nlevs in some cases)
bc <- vapply(reStruc, function(x) x$blockCode, numeric(1)) ## code block
block.rr <- which(bc == 9)
nbseq <- rep.int(seq_along(nb), nb * nc)       ## splitting vector
ml.b <- split(pl$b, nbseq)
ml <- ml.b
for (i in seq_along(ml.b)) {
  ml[[i]] <- matrix(ml.b[[i]], ncol = nc[i], byrow = TRUE,
                    dimnames = list(NULL, cnms[[i]]))
}

fl <- object$obj$env$report(object$fit$parfull)$fact_load[[1]]
rownames(fl) <- cnms$Country
u <- as.matrix(ml[[block.rr]][,1:2])
rownames(u) <- levs$Country
b.rr <- fl%*% t(u)
b.rr.long <- as.data.frame(b.rr) %>%
  rownames_to_column("Coefficient") %>%
  pivot_longer(cols = -Coefficient, names_to = c("Country"), values_to = "lu" )

b.oth <- t(ml[[-block.rr]])
colnames(b.oth) <- levs$Country
b.oth.long <- as.data.frame(b.oth) %>%
  rownames_to_column("Coefficient") %>%
  pivot_longer(cols = -Coefficient, names_to = c("Country"), values_to = "u.other" )

b.all <- left_join(b.rr.long, b.oth.long, by = intersect(names(b.rr.long), names(b.oth.long)))

pl <- object$obj$env$parList(object$fit$par, object$fit$parfull)
b0 <- which(ml.b[[block.rr]]==0)
s1 <- TMB::sdreport(object$obj,  getJointPrecision = TRUE)
h.inv <- solve(s1$jointPrecision)
h.inv.b <- h.inv[rownames(h.inv)=="b", colnames(h.inv)=="b"]
h.inv.u <- h.inv.b[-b0, -b0]

I <- diag(rep(1, ncol(b.rr)))
I.fl <- kronecker(I, (fl))
rownames(I.fl) <- rep(cnms$Country, ncol(b.rr))
I.oth <- diag(rep(1, length(ml.b[[-block.rr]])))
I.u <- cbind(I.fl, I.oth)
# rownames(h.inv.u) <- colnames(h.inv.u) <- rep(levs$Country, 2)
H.l.u <- I.u %*% h.inv.u %*% t(I.u)
diag.H.lu <- diag(H.l.u)
diag.H.lu.df <- cbind(rownames(H.l.u), as.data.frame(diag.H.lu))
nam.grp <- rep(levs$Country, each =nrow(fl))
var.re <- cbind(diag.H.lu.df, nam.grp)
names(var.re) <- c("Coefficient", "var.u", "Country")

b.all$u <- b.all$lu + b.all$u.other
ranef.rr <- left_join(b.all, var.re, by = intersect(names(b.all), names(var.re)))
ranef.rr$sd.u <- sqrt(ranef.rr$var.u)

### ----------
### Case 3: rr +diag + other random effect
### ----------

pirls_sub3 <- pirls_df %>%
  filter(as.numeric(Country) < 15 & as.numeric(School) < 30)
pirls_sub3$Overall <- pirls_sub3$Overall1
pirls_sub3$School <- pirls_sub3$SchoolsInCountry
pirls_sub3 <- na.omit(pirls_sub3)

pirls <- pirls_df
pirls$Overall <- pirls$Overall1
pirls$School <- pirls$SchoolsInCountry
# pirls  <- na.omit(pirls)

fit.rr3 <- glmmTMB(Overall ~  Size_lib*Eco_disad +
                    (1 |School) +
                    rr(Size_lib*Eco_disad | Country, rank)+
                    diag(Size_lib*Eco_disad | Country) ,
                  data = pirls,
                  family = gaussian(),
                  control = glmmTMBControl(optCtrl=list(iter.max=1e5,eval.max=1e3),
                                           start_method = list(method = "res")))


object <- fit.rr3
listname <- "cond"
cnms <- object$modelInfo$reTrms[[listname]]$cnms   ## list of (named) terms and X columns
reStruc <- object$modelInfo$reStruc[[paste0(listname, "ReStruc")]] ## random-effects structure
flist <- object$modelInfo$reTrms[[listname]]$flist ## list of grouping variables
levs <- lapply(flist, levels)
pl <- object$obj$env$parList(object$fit$par, object$fit$parfull)
nc <- vapply(reStruc, function(x) x$blockSize, numeric(1)) ## number of RE params per block
nb <- vapply(reStruc, function(x) x$blockReps, numeric(1)) ## number of blocks per RE (may != nlevs in some cases)
bc <- vapply(reStruc, function(x) x$blockCode, numeric(1)) ## code block
block.rr <- which(bc == 9)
nbseq <- rep.int(seq_along(nb), nb * nc)       ## splitting vector
ml.b <- split(pl$b, nbseq)
ml <- ml.b
for (i in seq_along(ml.b)) {
  ml[[i]] <- matrix(ml.b[[i]], ncol = nc[i], byrow = TRUE,
                    dimnames = list(NULL, cnms[[i]]))
}
asgn <- attr(flist, "assign")
asgn.rr <- asgn[block.rr]
asgn[block.rr] <- 0
block.oth <- which(asgn == asgn.rr)
fl <- object$obj$env$report(object$fit$parfull)$fact_load[[block.rr]]
rownames(fl) <- cnms[[block.rr]]
u <- as.matrix(ml[[block.rr]][,1:2])
rownames(u) <- levs$Country
b.rr <- fl%*% t(u)
b.rr.long <- as.data.frame(b.rr) %>%
  rownames_to_column("Coefficient") %>%
  pivot_longer(cols = -Coefficient, names_to = c("Country"), values_to = "lu" )

b.oth <- t(ml[[block.oth]])
colnames(b.oth) <- levs$Country
b.oth.long <- as.data.frame(b.oth) %>%
  rownames_to_column("Coefficient") %>%
  pivot_longer(cols = -Coefficient, names_to = c("Country"), values_to = "u.other" )
b.all <- left_join(b.rr.long, b.oth.long, by = intersect(names(b.rr.long), names(b.oth.long)))

b0 <- which(ml.b[[block.rr]]==0)
s1 <- TMB::sdreport(object$obj,  getJointPrecision = TRUE)
h.inv <- solve(s1$jointPrecision)
h.inv.b <- h.inv[rownames(h.inv)=="b", colnames(h.inv)=="b"]

b.cols <- split(1:ncol(h.inv.b), nbseq)
b.toget <- c(block.rr, block.oth)
b.cols.toget <- c(sapply(b.toget, function(i) b.cols[[i]]))
h.inv.b.tmp <- h.inv.b[b.cols.toget, b.cols.toget]
h.inv.u <- h.inv.b.tmp[-b0, -b0]

I <- diag(rep(1, ncol(b.rr)))
I.fl <- kronecker(I, (fl))
rownames(I.fl) <- rep(cnms$Country, ncol(b.rr))
I.oth <- diag(rep(1, length(ml.b[[block.oth]])))
I.u <- cbind(I.fl, I.oth)
# rownames(h.inv.u) <- colnames(h.inv.u) <- rep(levs$Country, 2)
H.l.u <- I.u %*% h.inv.u %*% t(I.u)
diag.H.lu <- diag(H.l.u)
diag.H.lu.df <- cbind(rownames(H.l.u), as.data.frame(diag.H.lu))
nam.grp <- rep(levs$Country, each =nrow(fl))
var.re <- cbind(diag.H.lu.df, nam.grp)
names(var.re) <- c("Coefficient", "var.u", "Country")

b.all$u <- b.all$lu + b.all$u.other
ranef.rr <- left_join(b.all, var.re, by = intersect(names(b.all), names(var.re)))
ranef.rr$sd.u <- sqrt(ranef.rr$var.u)

save.image("Results/pirls_re_se.RData")

#### other fucntions
rand.se <- purrr::map(rand.ef, function(.x) {
  cnt <- nrow(.x) * ncol(.x)
  s3 <- s2[1:cnt]
  s2 <- s2[-(1:cnt)]
  as.data.frame(matrix(sqrt(s3), ncol = ncol(.x), byrow = TRUE))
})
## Find the lengths of each re
re.len <- purrr::map(rand.ef, function(.x) {
  count <- nrow(.x) * ncol(.x)
})

ranef.glmmTMB <- function(object, condVar=TRUE) {
  ## The arrange() function converts a vector of random effects to a list of
  ## data frames, in the same way as lme4 does.
  ## FIXME: add condVar, make sure format matches lme4
  arrange <- function(x, sd, listname) {
    cnms <- object$modelInfo$reTrms[[listname]]$cnms   ## list of (named) terms and X columns
    reStruc <- object$modelInfo$reStruc[[paste0(listname, "ReStruc")]] ## random-effects structure
    flist <- object$modelInfo$reTrms[[listname]]$flist ## list of grouping variables
    levs <- lapply(flist, levels)
    if (!is.null(cnms)) {  ## FIXME: better test?
      asgn <- attr(flist, "assign")
      ## FIXME: blockReps/blockSize etc. _should_ be stored as integers ...
      nc <- vapply(reStruc, function(x) x$blockSize, numeric(1)) ## number of RE params per block
      nb <- vapply(reStruc, function(x) x$blockReps, numeric(1)) ## number of blocks per RE (may != nlevs in some cases)
      nbseq <- rep.int(seq_along(nb), nb * nc)       ## splitting vector
      ml <- split(x, nbseq)
      for (i in seq_along(ml)) {
        ml[[i]] <- matrix(ml[[i]], ncol = nc[i], byrow = TRUE,
                          dimnames = list(NULL, cnms[[i]]))
      }
      if (!is.null(sd)) {
        sd <- split(sd, nbseq)
        for (i in seq_along(sd)) {
          a <- array(NA, dim=c(nc[i], nc[i], nb[i]))
          ## fill in diagonals: off-diagonals will stay NA (!)
          ## unless we bother to retrieve conditional covariance info
          ## from the fit
          ## when nc>1, what order is the sd vector in?
          ## guessing, level-wise
          for (j in seq(nb[i])) {
            a[cbind(seq(nc[i]),seq(nc[i]),j)] <-
              (sd[[i]][nc[i]*(j-1)+seq(nc[i])])^2
          }
          sd[[i]] <- a
        }
      }
      ## combine RE matrices from all terms with the same grouping factor
      x <- lapply(seq_along(flist),
                  function(i) {
                    m <- ml[asgn == i]
                    b2 <- vapply(m, nrow, numeric(1))
                    ub2 <- unique(b2)
                    if (length(ub2)>1)
                      stop("differing numbers of b per group")
                    ## if number of sets of modes != number of levels (e.g. Gaussian process/phyloglmm),
                    ##   generate numeric sequence for names
                    rnms <- if (ub2==length(levs[[i]])) levs[[i]] else seq(ub2)
                    d <- data.frame(do.call(cbind, m),
                                    row.names = rnms,
                                    check.names = FALSE)

                    if (!is.null(sd)) {
                      ## attach conditional variance info
                      ## called "condVar", *not* "postVar" (contrast to lme4)
                      attr(d, "condVar") <- if (length(w <- which(asgn==i))>1) {
                        ## FIXME: set names?
                        sd[w]  ## if more than one term, list
                      } else sd[[w]]  ## else just the array
                    }
                    return(d)
                  })
      names(x) <- names(flist)
      return(x)
    } ## if !is.null(cnms)
    else {
      list()
    }
  } ## arrange()
  getParList <- function(object) {
    object$obj$env$parList(object$fit$par, object$fit$parfull)
  }
  pl <- getParList(object)  ## see VarCorr.R
  if (condVar && hasRandom(object))  {
    ss <- summary(object$sdr,"random")
    sdl <- list(b=ss[rownames(ss)=="b","Std. Error"],
                bzi=ss[rownames(ss)=="bzi","Std. Error"])
  }  else sdl <- NULL
  structure(list(cond = arrange(pl$b, sdl$b, "cond"),
                 zi    = arrange(pl$bzi, sdl$bzi, "zi")),
            class = "ranef.glmmTMB")
}
# save.image("Results/pirls_rr_eco_lib.RData")
## ------
# RE plot
## ------
library(sjPlot)
mod_info <- get_model_data(fit.rr, type = "re", transform = NULL)
rr_mod_info <- mod_info[[2]]

facet_levels <- c("(Intercept)",
                  "Size_lib501-5,000 Book Titles",
                  "Size_libMore than 5,000 Book Titles",
                  "Eco_disad11 to 25%",
                  "Size_lib501-5,000 Book Titles:Eco_disad11 to 25%",
                  "Size_libMore than 5,000 Book Titles:Eco_disad11 to 25%",
                  "Eco_disad26 to 50%",
                  "Size_lib501-5,000 Book Titles:Eco_disad26 to 50%",
                  "Size_libMore than 5,000 Book Titles:Eco_disad26 to 50%",
                  "Eco_disadMore than 50%",
                  "Size_lib501-5,000 Book Titles:Eco_disadMore than 50%",
                  "Size_libMore than 5,000 Book Titles:Eco_disadMore than 50%"
)
library(RColorBrewer)
ggplot(ranef.rr,
       aes(x = as.factor(Country)  ,
           y = u)) +
  geom_point()+
  geom_linerange(aes(ymin = u - 1.96*sd.u, ymax = u + 1.96*sd.u)) +
  geom_hline(yintercept = 0, linetype  = "dashed") +
  facet_grid(~ factor(Coefficient, levels = facet_levels, ordered = T), scales = "free") +
  coord_flip() + theme_mine() +
  xlab("Country")+
  theme( axis.text = element_text( size = 12 ),
         axis.text.y = element_text( size = 10),
         axis.text.x = element_text( size = 8),
         axis.title = element_text( size = 12),
         strip.text = element_text(size = 8),
         legend.position="none",
         strip.text.x = element_text(size=8, angle=90, hjust = 0, vjust =0.1))+
  scale_fill_brewer(palette = "Paired")

## ------
### Prediction plot of interaction
## ------
pirls_pred <- pirls %>%
  droplevels() %>%
  select( Country, Eco_disad, Size_lib, School) %>%
  distinct()
pirls_pred$School <- NA
pred1 <- predict(fit.rr, newdata = pirls_pred, allow.new.levels = T)
pirls_pred$pred_yc <- pred1

pirls_pred$Eco_Lib <- with(pirls_pred, interaction(Eco_disad,  Size_lib ))
levels_eco_lib <- c("0 to 10%.500 Book Titles or Fewer","0 to 10%.501-5,000 Book Titles",
                    "0 to 10%.More than 5,000 Book Titles",
                    "11 to 25%.500 Book Titles or Fewer",  "11 to 25%.501-5,000 Book Titles",
                    "11 to 25%.More than 5,000 Book Titles",
                    "26 to 50%.500 Book Titles or Fewer", "26 to 50%.501-5,000 Book Titles",
                    "26 to 50%.More than 5,000 Book Titles",
                    "More than 50%.500 Book Titles or Fewer",  "More than 50%.501-5,000 Book Titles",
                    "More than 50%.More than 5,000 Book Titles")
pirls_pred$Eco_lib2 <- factor(pirls_pred$Eco_Lib, levels = levels_eco_lib, ordered = T )


book_labels <- c("< 500", "501-5,000" , "> 5,000" )
pirls_pred <- pirls_pred %>%
  arrange(Eco_lib2, Country)

library(RColorBrewer)
library(grid)
nb.cols <- 25
mycolors <- colorRampPalette(brewer.pal(8, "Paired"))(nb.cols)

country_levels <- levels(pirls_pred$Country)
country1 <- "Buenos Aires, Argentina"
country2 <- "Georgia"
col_country <- mycolors[c(which(country_levels == country1), which(country_levels == country2))]
ggplot(filter( pirls_pred, Country == country1 | Country ==country2 ),
       aes(x=Eco_disad, y=pred_yc,
           group=Size_lib,
           color=Size_lib #,
           # label = Eco_disad
       )) +
  geom_line()+ theme_mine() +
  ylab("Literacy score")  +
  xlab("Economic disadvantage")+
  theme(axis.text.x = element_text(size=8, angle=30, hjust = 1, vjust =0.9),
        axis.text = element_text( size = 8 ),
        legend.position= c(0.9, 0.8)) +
  facet_grid(~ Country) +
  scale_colour_discrete("Library Size")+
  theme(legend.title = element_text(size = 10),
        legend.text = element_text(size = 8))

### Plot of random slopes (interaction) for every country
p <- ggplot(pirls_pred,
            aes(x=Eco_lib2, y=pred_yc,
                group=Country,
                color=Country,
                label = Eco_disad)) +
  geom_line()+ theme_mine() +
  ylab("Literacy score") +
  scale_x_discrete(labels = rep(book_labels, 4))+
  scale_color_manual(values = mycolors) +
  xlab("              0-10%            11 to 25%          26 to 50%          More than 50%      ")+
  theme(axis.text.x = element_text(size=8, angle=30, hjust = 1, vjust =0.9),
        axis.text = element_text( size = 8 ))



#### Functions from glmmTMB

object <- fit.rr
coefMer <- function(object, component=NULL, ...)
{
  if (length(list(...)))
    warning('arguments named "', paste(names(list(...)), collapse = ", "),
            '" ignored')
  fef <- fixef(object)
  if (!is.null(component)) fef <- fef[[component]]
  fef <- data.frame(rbind(fef), check.names = FALSE)
  ref <- ranef(object)
  if (!is.null(component)) ref <- ref[[component]]
  ## check for variables in RE but missing from FE, fill in zeros in FE accordingly
  refnames <- unlist(lapply(ref,colnames))
  nmiss <- length(missnames <- setdiff(refnames,names(fef)))
  if (nmiss > 0) {
    fillvars <- setNames(data.frame(rbind(rep(0,nmiss))),missnames)
    fef <- cbind(fillvars,fef)
  }
  val <- lapply(ref, function(x)
    fef[rep.int(1L, nrow(x)),,drop = FALSE])
  for (i in seq(a = val)) {
    refi <- ref[[i]]
    row.names(val[[i]]) <- row.names(refi)
    nmsi <- colnames(refi)
    if (!all(nmsi %in% names(fef)))
      stop("unable to align random and fixed effects")
    for (nm in nmsi) val[[i]][[nm]] <- val[[i]][[nm]] + refi[,nm]
  }
  class(val) <- "coef.mer"
  val
} ##  {coefMer}

coef.glmmTMB <- function(object,
                         condVar=FALSE, ...) {
  model.has.component <- function(x) {
    !is.null(object$modelInfo$reTrms[[x]]$cnms)
  }
  get.coef <- function(x) {
    if (!model.has.component(x)) return(list())
    return(coefMer(object, component=x))
  }
  res <- list(
    cond = get.coef("cond"),
    zi = get.coef("zi")
  )
  if (condVar) {
    stop("condVar not (yet) available for coefficients")
    sdr <- TMB::sdreport(object$obj, getJointPrecision=TRUE)
    v <- solve(sdr$jointPrecision)
    ## FIXME:: sort out variance calculation, using Z and X
  }
  class(res) <- "coef.glmmTMB"
  return(res)
}
